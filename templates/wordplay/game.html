<!DOCTYPE html>

<html lang="en">

<head>

    {% include "wordplay/head.html" %}

    <!-- <link rel="stylesheet" href="{{ url_for('static', filename='wordplay/all.css') }}">
    <link rel="stylesheet" href="{{ url_for('static', filename='wordplay/results_page.css') }}"> -->

    <style>

        body {
            margin: 0;
            padding: 3vw;
            font-family: 'roboto_light', sans-serif;
            text-align: center;
            background-color: black;
        }

        #win-heading, #win-stats {
            color: hsl(102, 100%, 50%);
        }
        #lose-heading {
            color: hsl(0, 100%, 50%);
        }
        #lose-heading, #win-heading, #win-stats {
            display: none;
        }
        #win-stats {
            font-weight: normal;
            font-size: small;
        }

        /* Game Stats Bar */
        #stats-bar {
            justify-content: space-between;
        }
        #stats-bar, #strike-area, #arrow-area {
            display: flex;
        }
        #stats-bar, #arrow-area {
            flex-wrap: wrap;
        }
        /* #arrow-area img {
            transition: height 0.5s;
        } */
        #strike-area, #arrow-area {
            margin-bottom: 0.6em;
        }
        .strike-box, #strike-area img {
            height: 100%;
        }
        #strike-area, #arrow-area img {
            display: flex;
            height: 2em;
        }
        #strike-area, .strike-box {
            box-sizing: border-box;
            border: 1px solid white;
        }
        .strike-box {
            aspect-ratio: 1 / 1;
        }
        #arrow-area img {
            margin-left: 1vw;
        }

        /* Synset Text Styling */
        .words {
            font-family: Futura, "Century Gothic", sans-serif;
            font-size: 1.4rem;
        }
        .pointer {
            color: hsl(313, 100%, 50%);
        }
        .pointer, .pos {
            font-style: italic;
        }
        .pos {
            opacity: 50%;
        }
        .gloss {
            opacity: 70%;
        }

        /* Previous/Current Synset Areas */
        #prev-synsets {
            margin: 3vw 0;
            color: hsl(133, 0%, 60%);
        }
        #curr-synset {
            border: 5px solid white;
            padding: 2vw 0;
            background-color: hsl(0, 0%, 10%);
            color: hsl(313, 100%, 50%);
        }

        /* Next Synset Area */
        #next-synset-area {
            display: flex;
        }
        #next-synsets {
            flex: 18;
        }
        #next-syn-b-gutter, #next-syn-a-gutter {
            flex: 1;
        }
        #next-synsets .words {
            font-weight: bold;
        }
        #next-syn-a-gutter, #next-syn-a-text {
            background-color: hsl(86, 100%, 50%);
        }
        #next-syn-b-gutter, #next-syn-b-text {
            background-color: hsl(180, 100%, 50%);
        }
        #next-syn-a-text {
            border-top: 5px solid black;
            border-right: 5px solid black;
            padding: 3vw 3vw 3vw 0;
            text-align: left;
        }
        #next-syn-b-text {
            border-left: 5px solid black;
            padding: 3vw 0 3vw 3vw;
            text-align: right;
        }

        /* Target Synset Area */
        #target-margin {
            height: 3vw;
            border-top: 5px solid white;
            border-bottom: 5px solid white;
        }
        #target-heading {
            color: hsl(133, 100%, 80%);
        }
        #target {
            box-sizing: border-box;
            padding: 3vw;
            background-color: hsla(0, 0%, 100%, 10%);
            color: hsl(0, 0%, 100%);
        }

    </style>
    
</head>

<body>

    <!-- <h4 style="color: white">0123456789</h4> -->
    <!-- <h4 style="color: white">abcdefghijklmnopqrst</h4> -->

    <div id="stats-bar">

        <div id="strike-area">
            <!-- <div class="strike-box">
                <img src="/static/red_x.png">
            </div> -->
        </div>

        <div id="arrow-area">
            <!-- <img src="/static/arrow_outline.png"> -->
        </div>

    </div>

    <h1 id='lose-heading'>LOSE</h1>
    <h1 id='win-heading'
        >WIN<br>
        <span id='win-stats'></span>
    </h1>

    <div id="prev-synsets">
        <!-- <div class="words">apple, air potato</div> -->
    </div>

    <div id="curr-synset">
        <span class="words"></span>
    </div>

    <div id="next-synset-area">

        <div id="next-syn-a-gutter"></div>

        <div id="next-synsets">

            <div id="next-syn-b-text">
                <span class="pointer"></span>
                <br>
                <span class="words"></span><span class="pos"></span>
                <br>
                <span class="gloss"></span>
            </div>

            <div id="next-syn-a-text">
                <span class="pointer"></span>
                <br>
                <span class="words"></span><span class="pos"></span>
                <br>
                <span class="gloss"></span>
            </div>

        </div>

        <div id="next-syn-b-gutter"></div>

    </div>

    <div id="target-margin"></div>

    <div id="target">
        <span id="target-heading">TARGET</span>
        <span class="pointer" style="display: none"></span>
        <br>
        <span class="words"></span><span class="pos"></span>&nbsp;&nbsp;
        <br>
        <span class="gloss"></span>
    </div>

</body>

<!-- <script src="{{ url_for('static', filename='wordplay/menu.js') }}"></script> -->

<script>


const pointer_key = {
    '^': 'which is related to',  // non-reflexive
    // '__start': {'name': 'start', 'phrase': '(start marker)',  // custom pointer type
    // '__end': {'name': 'end', 'phrase': '(end marker)',  // custom pointer type
    '?p': 'which is the same word as',  // custom pointer type  // self-reflexive
    '!': 'which is the opposite of',  // self-reflexive
    '&': 'which is similar to',  // self-reflexive
    '$': 'which is a related verb to',  // self-reflexive
    '=': 'which is a value or attribute of',  // self-reflexive
    '+': 'which has the same root form as',  // self-reflexive
    // Remaining pointers are ordered with reflexive pointers paired together.
    '@': 'which is a kind of',
    '~': 'a kind of which is',
    '@i': 'which is an instance of',
    '~i': 'an instance of which is',
    '#m': 'which is a member of',
    '%m': 'a member of which is',
    '#s': 'which is a substance of',
    '%s': 'a substance of which is',
    '#p': 'which is a part of',
    '%p': 'a part of which is',
    ';c': 'which is associated with the category',
    '-c': 'which is a category sometimes associated with',
    ';r':'which is associated with the region',
    '-r': 'which is a region sometimes associated with',
    ';u': 'which is associated with the usage',
    '-u': 'which is a usage sometimes associated with',
    '<': 'which is an adjective derived from the verb',
    '<x': 'which is the root verb for the adjective',
    // custom reflex pointer (above)
    '\\': 'which is of or pertaining to',
    '\\x': 'which is the basis for',  // custom reflex pointer
    '*': 'which cannot be done without',
    '*x': 'which is always done with',  // custom reflex pointer
    '>': 'which is caused by',
    '>x': 'which can cause',  // custom reflex pointer
};

const gameData = [[[{"2": "~"}, {"3": "~", "4": "~"}, ["trait"], "noun", "a distinguishing feature of your personal nature"], [{}, {}, ["unmindful", "forgetful", "mindless"], "adj", "not mindful or attentive; \"while thus unmindful of his steps he stumbled\"- G.B.Shaw"], [{"5": "~", "6": "~"}, {"7": "+", "8": "~"}, ["attentiveness"], "noun", "the trait of being observant and paying attention"], [{"7": "+"}, {"14": "#p", "15": "="}, ["thoughtfulness"], "noun", "the trait of thinking carefully before acting"], [{"0": "@"}, {"9": "~", "10": "~"}, ["drive"], "noun", "the trait of being highly motivated; \"his drive and energy exhausted his co-workers\""], [{"1": "="}, {}, ["mindfulness", "heedfulness"], "noun", "the trait of staying aware of (paying close attention to) your responsibilities"], [{"1": "+"}, {}, ["unmindfulness", "heedlessness", "inadvertence", "inadvertency"], "noun", "the trait of forgetting or ignoring your responsibilities"], [{"5": "+"}, {"16": "+", "17": "="}, ["heedful", "attentive", "thoughtful", "paying_attention"], "adj", "taking heed; giving close and thoughtful attention; \"heedful of the warnings\"; \"so heedful a writer\"; \"heedful of what they were doing\""], [{"11": "+", "2": "@"}, {"12": "+", "13": "+"}, ["caution", "cautiousness", "carefulness"], "noun", "the trait of being cautious; being attentive to possible danger; \"a man of caution\""], [{}, {}, ["energy", "push", "get-up-and-go"], "noun", "enterprising or ambitious drive; \"Europeans often laugh at American energy\""], [{}, {}, ["action"], "noun", "the trait of being active and energetic and forceful; \"a man of action\""], [{"5": "+"}, {"18": "&", "19": "\\x"}, ["careful", "heedful"], "adj", "cautiously attentive; \"careful of her feelings\"; \"heedful of his father's advice\""], [{}, {}, ["cautious"], "adj", "showing careful forethought; \"reserved and cautious; never making swift decisions\"; \"a cautious driver\""], [{}, {}, ["careful", "thrifty"], "adj", "mindful of the future in spending money; \"careful with money\""], [{}, {}, ["character", "fiber", "fibre"], "noun", "the inherent complex of attributes that determines a persons moral and ethical actions and reactions; \"education has for its object the formation of character\"- Herbert Spencer"], [{}, {}, ["thoughtful"], "adj", "exhibiting or characterized by careful thought; \"a thoughtful paper\""], [{}, {}, ["attend", "hang", "advert", "pay_heed", "give_ear"], "verb", "give heed (to); \"The children in the audience attended the recital quietly\"; \"She hung on his every word\"; \"They attended to everything he said\""], [{}, {}, ["attentiveness", "heed", "regard", "paying_attention"], "noun", "paying particular notice (as to children or helpless people); \"his attentiveness to her wishes\"; \"he spends without heed to the consequences\""], [{}, {}, ["mindful", "aware"], "adj", "bearing in mind; attentive to; \"ever mindful of her health\"; \"mindful of his responsibilities\"; \"mindful of these criticisms, I shall attempt to justify my action\""], [{}, {}, ["mindfully", "heedfully", "advertently"], "adv", "in a careful deliberate manner"]], 0, 1, 2];
const gameGraph = gameData[0];
const startSynsetIndex = gameData[1];
const targetSynsetIndex = gameData[2];
const totalStrikes = gameData[3];


const textFxTimeoutIds = {};




let currentSynsetIndex = startSynsetIndex;
let currentStrikes = 0;
let currentSteps = 0;

// Create HTML element references within nextSynsObj.
const nextSynsObj = {};
for (const aOrB of ['a', 'b']) {
    const areaSelector = `#next-syn-${aOrB}-text`;
    nextSynsObj[aOrB] = {
        index: null,  // ?????????????????????????????????????????????????????
        direction: null,  // 0 is correct, 1 is decoy.
        area: document.querySelector(areaSelector),
        // pointer: document.querySelector(`${areaSelector} span.pointer`),
        // words: document.querySelector(`${areaSelector} span.words`),
        // pos: document.querySelector(`${areaSelector} span.pos`),
        // gloss: document.querySelector(`${areaSelector} span.gloss`),
    };
};

// Add empty strike boxes.
const strikeArea = document.getElementById('strike-area');
for (let strikeCount = 0; strikeCount < totalStrikes; strikeCount++) {
    const newStrikeBox = document.createElement('div');
    newStrikeBox.id = (`strike-box-${strikeCount + 1}`);
    newStrikeBox.classList.add('strike-box');
    strikeArea.appendChild(newStrikeBox);
};
        
// Init target.
document.querySelector('#target span.words').innerHTML = wordsStrFromArray(gameGraph[targetSynsetIndex][2], true);
document.querySelector('#target span.pos').innerHTML = gameGraph[targetSynsetIndex][3];
document.querySelector('#target span.gloss').innerHTML = gameGraph[targetSynsetIndex][4];

// Create event listeners.
for (const aOrB of ['a', 'b'])
    nextSynsObj[aOrB]['area'].addEventListener('click', () => choose(aOrB));

choose();




function addSynToPrevList(synsetIndex) {
    const prevSynsets = document.getElementById('prev-synsets');
    const synsetToAdd = document.createElement('div');
    const wordsArray = gameGraph[synsetIndex][2];
    synsetToAdd.innerHTML = wordsStrFromArray(wordsArray);
    synsetToAdd.classList.add('words');
    prevSynsets.appendChild(synsetToAdd);
};

function choose(aOrB=null) {  // To init at game start, run choose(null).

    currentSteps++;

    // Add arrow.
    const arrowArea = document.getElementById('arrow-area');
    const newArrow = document.createElement('img');
    newArrow.src = '/static/arrow_outline.png';
    arrowArea.appendChild(newArrow);
    // newArrow.style.height = '0';  // working here !@#!@#$!@#$
    // newArrow.style.transition = 'height 2s';
    // newArrow.style.height = '2em';  // Match CSS.

    if (aOrB !== null) {

        addSynToPrevList(currentSynsetIndex);
        currentSynsetIndex = nextSynsObj[aOrB]['index'];  // Update currentSynsetIndex to chosen.

        if (nextSynsObj[aOrB]['direction'] === 1) {
            // Add strike.
            currentStrikes += 1;
            const strikeBox = document.getElementById(`strike-box-${currentStrikes}`)
            const newX = document.createElement('img');
            newX.src = '/static/red_x.png';
            strikeBox.appendChild(newX);
            if (currentStrikes >= totalStrikes) {
                lose();
                return;
            };
        };
    };

    // Update pointers.
    //

    const currentSynsetData = gameGraph[currentSynsetIndex];

    let pointerLetterNames = ['a', 'b'];
    if (Math.random() < 0.5) pointerLetterNames = ['b', 'a'];
    
    let pointerDataIndex = 0;  // Correct is at 0, decoy is at 1.
    for (const aOrB of pointerLetterNames) {

        const correctOrDecoy = ['CORRECT', 'DECOY'][pointerDataIndex];  // debug !@#$!@#$!@#$

        const allGroupPointerIndices = Object.keys(currentSynsetData[pointerDataIndex]);

        if (allGroupPointerIndices.length > 0) {

            const pointerIndex = allGroupPointerIndices[0];  // Getting first. Should instead be least recent.
            const pointerSymbol = currentSynsetData[pointerDataIndex][pointerIndex];
            const pointerPhrase = pointer_key[pointerSymbol];

            if (allGroupPointerIndices.includes(String(targetSynsetIndex))) {
                win(pointerPhrase);
                return;
            };
            
            nextSynsObj[aOrB]['index'] = pointerIndex;
            nextSynsObj[aOrB]['direction'] = pointerDataIndex;



            // pointer: document.querySelector(`${areaSelector} span.pointer`),
            // words: document.querySelector(`${areaSelector} span.words`),
            // pos: document.querySelector(`${areaSelector} span.pos`),
            // gloss: document.querySelector(`${areaSelector} span.gloss`),

            const areaSelector = `#next-syn-${aOrB}-text span.`;


            textChangeEffect(`${areaSelector}pointer`, pointerPhrase);
            textChangeEffect(`${areaSelector}words`, wordsStrFromArray(gameGraph[pointerIndex][2], true) + ` ${correctOrDecoy}`);  // debug !@#$!@#$
            textChangeEffect(`${areaSelector}pos`, gameGraph[pointerIndex][3]);
            textChangeEffect(`${areaSelector}gloss`, gameGraph[pointerIndex][4]);
            // nextSynsObj[aOrB]['pointer'].innerHTML = pointerPhrase;
            // nextSynsObj[aOrB]['words'].innerHTML = wordsStrFromArray(gameGraph[pointerIndex][2], true) + ` ${correctOrDecoy}`;  // debug !@#$!@#$
            // nextSynsObj[aOrB]['pos'].innerHTML = gameGraph[pointerIndex][3];
            // nextSynsObj[aOrB]['gloss'].innerHTML = gameGraph[pointerIndex][4];

        } else {
            // Should not happen. Synsets should always have at least 1 correct and decoy pointer unless target or strike limit is reached.
            console.log('should not happen?????? No')
            lose();
            return;
        };

        pointerDataIndex = 1;
    };

    // End update pointers.
    //

    // Update current synset element if not returned above.
    const newCurrentWords = gameGraph[currentSynsetIndex][2];
    const currSynsetElem = document.querySelector('#curr-synset span.words');
    currSynsetElem.innerHTML = '';
    // textChangeEffect(currSynsetElem, wordsStrFromArray(newCurrentWords));
    currSynsetElem.innerHTML = wordsStrFromArray(newCurrentWords);
};


function lose() {
    document.body.style.backgroundColor = 'hsl(0, 100%, 5%)';
    document.getElementById('lose-heading').style.display = 'block';
    document.getElementById('target-margin').style.borderColor = 'red';
    addSynToPrevList(currentSynsetIndex);
    for (const elemId of ['curr-synset', 'next-synset-area'])
        document.getElementById(elemId).style.display = 'none';
};


function win(finalPointerPhrase) {
    document.body.style.backgroundColor = 'hsl(102, 100%, 5%)';
    document.getElementById('win-heading').style.display = 'block';
    document.getElementById('win-stats').style.display = 'block';
    document.getElementById('win-stats').innerHTML = `in ${currentSteps} steps`;
    addSynToPrevList(currentSynsetIndex);
    for (const elemId of ['curr-synset', 'next-synset-area', 'target-margin'])
        document.getElementById(elemId).style.display = 'none';
    document.querySelector('#target-heading').style.display = 'none';
    document.querySelector('#target span.pointer').innerHTML = finalPointerPhrase;
    document.querySelector('#target span.pointer').style.display = 'inline';
};


function wordsStrFromArray(wordsArray, addEndingSpace=false) {
    let synsetWordString = '';
    for (let wordNum = 0; wordNum < wordsArray.length; wordNum++) {
        if (wordNum > 0) synsetWordString += ', ';
        synsetWordString += wordsArray[wordNum];
    };
    if (addEndingSpace) synsetWordString += ' ';
    return synsetWordString;
};


function textChangeEffect(cssSelector, newText, charMsecs=10) {

    if (cssSelector in textFxTimeoutIds) {
        clearTimeout(textFxTimeoutIds[cssSelector]);
    };

    const elem = document.querySelector(cssSelector);
    const oldText = elem.innerText;

    const loopLength = Math.max(oldText.length, newText.length);
    // console.log(loopLength)

    if (newText.length >= oldText.length) {
        // Left to right.

        let index = 1;
        timeoutFunc();

        function timeoutFunc() {
            // console.log(index)
            const transitionText = newText.substring(0, index) + oldText.substring(index);
            elem.innerText = transitionText;
            // console.log(transitionText)
            index++;
            if (index <= loopLength) {
                // console.log(`index ${index}`)
                const timeoutId = setTimeout(timeoutFunc, charMsecs);
                textFxTimeoutIds[cssSelector] = timeoutId;
            };
        };

    } else {
        // Right to left.

        let index = loopLength - 1;
        timeoutFunc();

        function timeoutFunc() {
            // console.log(index)
            const transitionText = oldText.substring(0, index) + newText.substring(index);
            // console.log(transitionText)
            elem.innerText = transitionText;
            index--;
            if (index >= 0) {
                const timeoutId = setTimeout(timeoutFunc, charMsecs);
                textFxTimeoutIds[cssSelector] = timeoutId;
            };
        };
    };
};


window.addEventListener('keydown', () => {
    // textChangeEffect('h4', 'abcdefghijklmnopqrst', 500);
    // textChangeEffect('h4', '0123456789', 10);
    document.querySelector('#arrow-area img').style.height = '2em';
});


</script>

</html>
