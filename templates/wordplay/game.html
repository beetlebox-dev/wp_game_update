<!DOCTYPE html>

<html lang="en">

<head>

    {% include "wordplay/head.html" %}

    <!-- <link rel="stylesheet" href="{{ url_for('static', filename='wordplay/all.css') }}">
    <link rel="stylesheet" href="{{ url_for('static', filename='wordplay/results_page.css') }}"> -->

    <style>

        body {
            margin: 0;
            padding: 3vw;
            font-family: 'roboto_light', sans-serif;
            text-align: center;
            background-color: black;
        }

        /* Game Stats Bar */
        #stats-bar {
            justify-content: space-between;
        }
        #stats-bar, #strike-area, #arrow-area {
            display: flex;
        }
        #stats-bar, #arrow-area {
            flex-wrap: wrap;
        }
        #strike-area, #arrow-area {
            margin-bottom: 0.6em;
        }
        .strike-box, #strike-area img {
            height: 100%;
        }
        #strike-area, #arrow-area img {
            display: flex;
            height: 2em;
        }
        #strike-area, .strike-box {
            box-sizing: border-box;
            border: 1px solid white;
        }
        .strike-box {
            aspect-ratio: 1 / 1;
        }
        #arrow-area img {
            margin-left: 1vw;
        }

        /* Synset Text Styling */
        .words {
            font-family: Futura, "Century Gothic", sans-serif;
            font-size: 1.4rem;
        }
        .pointer {
            color: hsl(313, 100%, 50%);
        }
        .pointer, .pos {
            font-style: italic;
        }
        .pos {
            opacity: 50%;
        }
        .gloss {
            opacity: 70%;
        }

        /* Previous/Current Synset Areas */
        #prev-synsets {
            margin: 3vw 0;
            color: hsl(133, 0%, 60%);
        }
        #curr-synset {
            border: 5px solid white;
            padding: 2vw 0;
            background-color: hsl(0, 0%, 10%);
            color: hsl(313, 100%, 50%);
        }

        /* Next Synset Area */
        #next-synset-area {
            display: flex;
        }
        #next-synsets {
            flex: 18;
        }
        #next-syn-b-gutter, #next-syn-a-gutter {
            flex: 1;
        }
        #next-synsets .words {
            font-weight: bold;
        }
        #next-syn-a-gutter, #next-syn-a-text {
            background-color: hsl(86, 100%, 50%);
        }
        #next-syn-b-gutter, #next-syn-b-text {
            background-color: hsl(180, 100%, 50%);
        }
        #next-syn-a-text {
            border-top: 5px solid black;
            border-right: 5px solid black;
            padding: 3vw 3vw 3vw 0;
            text-align: left;
        }
        #next-syn-b-text {
            border-left: 5px solid black;
            padding: 3vw 0 3vw 3vw;
            text-align: right;
        }

        /* Target Synset Area */
        #target-margin {
            height: 3vw;
            border-top: 5px solid white;
            border-bottom: 5px solid white;
        }
        #target-heading {
            color: hsl(133, 100%, 80%);
        }
        #target {
            box-sizing: border-box;
            padding: 3vw;
            background-color: hsl(0, 0%, 10%);
            color: hsl(0, 0%, 100%);
        }

    </style>
    
</head>

<body>

    <div id="stats-bar">

        <div id="strike-area">
            <!-- <div class="strike-box">
                <img src="/static/red_x.png">
            </div> -->
        </div>

        <div id="arrow-area">
            <!-- <img src="/static/arrow_outline.png"> -->
        </div>

    </div>

    <div id="prev-synsets">
        <!-- <div class="words">apple, air potato</div> -->
    </div>

    <div id="curr-synset">
        <span class="words">shape, form</span>
    </div>

    <div id="next-synset-area">

        <div id="next-syn-a-gutter"></div>

        <div id="next-synsets">

            <div id="next-syn-b-text">
                <span class="pointer">a kind of which is</span>
                <br>
                <span class="words">condense, concentrate, contract </span><span class="pos">verb</span>
                <br>
                <span class="gloss">compress or concentrate; "Congress condensed the three-year plan into a six-month plan"</span>
            </div>

            <div id="next-syn-a-text">
                <span class="pointer">which is caused by</span>
                <br>
                <span class="words">change </span><span class="pos">verb</span>
                <br>
                <span class="gloss">undergo a change; become different in essence; losing one's or its original nature; "She changed completely as she grew older"; "The weather changed last night"</span>
            </div>

        </div>

        <div id="next-syn-b-gutter"></div>

    </div>

    <div id="target-margin"></div>

    <div id="target">
        <span id="target-heading">TARGET</span>
        <br>
        <span class="words">compression, condensation, contraction </span><span class="pos">noun</span>&nbsp;&nbsp;
        <br>
        <span class="gloss">the process or result of becoming smaller or pressed together; "the contraction of a gas on cooling"</span>
    </div>

</body>

<!-- <script src="{{ url_for('static', filename='wordplay/menu.js') }}"></script> -->

<script>






const pointer_key = {
    '^': 'which is related to',  // non-reflexive
    // '__start': {'name': 'start', 'phrase': '(start marker)',  // custom pointer type
    // '__end': {'name': 'end', 'phrase': '(end marker)',  // custom pointer type
    '?p': 'which is the same word as',  // custom pointer type  // self-reflexive
    '!': 'which is the opposite of',  // self-reflexive
    '&': 'which is similar to',  // self-reflexive
    '$': 'which is a related verb to',  // self-reflexive
    '=': 'which is a value or attribute of',  // self-reflexive
    '+': 'which has the same root form as',  // self-reflexive
    // Remaining pointers are ordered with reflexive pointers paired together.
    '@': 'which is a kind of',
    '~': 'a kind of which is',
    '@i': 'which is an instance of',
    '~i': 'an instance of which is',
    '#m': 'which is a member of',
    '%m': 'a member of which is',
    '#s': 'which is a substance of',
    '%s': 'a substance of which is',
    '#p': 'which is a part of',
    '%p': 'a part of which is',
    ';c': 'which is associated with the category',
    '-c': 'which is a category sometimes associated with',
    ';r':'which is associated with the region',
    '-r': 'which is a region sometimes associated with',
    ';u': 'which is associated with the usage',
    '-u': 'which is a usage sometimes associated with',
    '<': 'which is an adjective derived from the verb',
    '<x': 'which is the root verb for the adjective',
    // custom reflex pointer (above)
    '\\': 'which is of or pertaining to',
    '\\x': 'which is the basis for',  // custom reflex pointer
    '*': 'which cannot be done without',
    '*x': 'which is always done with',  // custom reflex pointer
    '>': 'which is caused by',
    '>x': 'which can cause',  // custom reflex pointer
};


const gameData = [[[{"2": "~"}, {"3": "~", "4": "~"}, ["trait"], "noun", "a distinguishing feature of your personal nature"], [{}, {}, ["unmindful", "forgetful", "mindless"], "adj", "not mindful or attentive; \"while thus unmindful of his steps he stumbled\"- G.B.Shaw"], [{"5": "~", "6": "~"}, {"7": "+", "8": "~"}, ["attentiveness"], "noun", "the trait of being observant and paying attention"], [{"7": "+"}, {"14": "#p", "15": "="}, ["thoughtfulness"], "noun", "the trait of thinking carefully before acting"], [{"0": "@"}, {"9": "~", "10": "~"}, ["drive"], "noun", "the trait of being highly motivated; \"his drive and energy exhausted his co-workers\""], [{"1": "="}, {}, ["mindfulness", "heedfulness"], "noun", "the trait of staying aware of (paying close attention to) your responsibilities"], [{"1": "+"}, {}, ["unmindfulness", "heedlessness", "inadvertence", "inadvertency"], "noun", "the trait of forgetting or ignoring your responsibilities"], [{"5": "+"}, {"16": "+", "17": "="}, ["heedful", "attentive", "thoughtful", "paying_attention"], "adj", "taking heed; giving close and thoughtful attention; \"heedful of the warnings\"; \"so heedful a writer\"; \"heedful of what they were doing\""], [{"11": "+", "2": "@"}, {"12": "+", "13": "+"}, ["caution", "cautiousness", "carefulness"], "noun", "the trait of being cautious; being attentive to possible danger; \"a man of caution\""], [{}, {}, ["energy", "push", "get-up-and-go"], "noun", "enterprising or ambitious drive; \"Europeans often laugh at American energy\""], [{}, {}, ["action"], "noun", "the trait of being active and energetic and forceful; \"a man of action\""], [{"5": "+"}, {"18": "&", "19": "\\x"}, ["careful", "heedful"], "adj", "cautiously attentive; \"careful of her feelings\"; \"heedful of his father's advice\""], [{}, {}, ["cautious"], "adj", "showing careful forethought; \"reserved and cautious; never making swift decisions\"; \"a cautious driver\""], [{}, {}, ["careful", "thrifty"], "adj", "mindful of the future in spending money; \"careful with money\""], [{}, {}, ["character", "fiber", "fibre"], "noun", "the inherent complex of attributes that determines a persons moral and ethical actions and reactions; \"education has for its object the formation of character\"- Herbert Spencer"], [{}, {}, ["thoughtful"], "adj", "exhibiting or characterized by careful thought; \"a thoughtful paper\""], [{}, {}, ["attend", "hang", "advert", "pay_heed", "give_ear"], "verb", "give heed (to); \"The children in the audience attended the recital quietly\"; \"She hung on his every word\"; \"They attended to everything he said\""], [{}, {}, ["attentiveness", "heed", "regard", "paying_attention"], "noun", "paying particular notice (as to children or helpless people); \"his attentiveness to her wishes\"; \"he spends without heed to the consequences\""], [{}, {}, ["mindful", "aware"], "adj", "bearing in mind; attentive to; \"ever mindful of her health\"; \"mindful of his responsibilities\"; \"mindful of these criticisms, I shall attempt to justify my action\""], [{}, {}, ["mindfully", "heedfully", "advertently"], "adv", "in a careful deliberate manner"]], 0, 1, 2];
const gameGraph = gameData[0]
const startSynsetIndex = gameData[1]
const targetSynsetIndex = gameData[2]
const totalStrikes = gameData[3]



// let currentSynsetIndex = startSynsetIndex;
let currentSynsetIndex
let currentStrikes = 0;




function getPointers(synsetIndex) {
    const pointerObjs = [];
    const synsetData = gameGraph[synsetIndex];
    for (const pointerGroup of [0, 1]) {  // Correct is 0, decoy is 1.
        const allGroupPointerIndices = Object.keys(synsetData[pointerGroup]);
        if (allGroupPointerIndices.length > 0) {
            const pointerIndex = allGroupPointerIndices[0];  // Getting first. Should instead be least recent.
            const pointerSymbol = synsetData[pointerGroup][pointerIndex];
            const pointerObj = {
                index: pointerIndex,
                pointer: pointer_key[pointerSymbol],
                words: wordsStrFromArray(gameGraph[pointerIndex][2]),
                pos: gameGraph[pointerIndex][3],
                gloss: gameGraph[pointerIndex][4],
            };
            pointerObjs.push(pointerObj);
        } else {
            const pointerObj = { index: null, pointer: 'pointer', words: 'words', pos: 'pos', gloss: 'gloss', };
            pointerObjs.push(pointerObj);
        };
    };
    return { a: pointerObjs[0], b: pointerObjs[1], };  // Should shuffle returned array so that correct is not always first.
};




const startingPointers = getPointers(startSynsetIndex);

const nextSynsObj = {};
for (const aOrB of ['a', 'b']) {

    // Create HTML element references.
    const areaId = `#next-syn-${aOrB}-text`;
    nextSynsObj[aOrB] = {
        index: startingPointers[aOrB]['index'],
        area: document.querySelector(areaId),
        pointer: document.querySelector(`${areaId} span.pointer`),
        words: document.querySelector(`${areaId} span.words`),
        pos: document.querySelector(`${areaId} span.pos`),
        gloss: document.querySelector(`${areaId} span.gloss`),
    };
};

choose();


function choose(aOrB=null) {  // If aOrB is null or not passed, currentSynsetIndex is initialized as the start synset.

    console.log(currentSynsetIndex)

    if (aOrB !== null) {

        // Add current synset to previous synset list.
        const prevSynsets = document.getElementById('prev-synsets');
        const synsetToAdd = document.createElement('div');
        const wordsArray = gameGraph[currentSynsetIndex][2];
        synsetToAdd.innerHTML = wordsStrFromArray(wordsArray);
        synsetToAdd.classList.add('words');
        prevSynsets.appendChild(synsetToAdd);

        currentSynsetIndex = nextSynsObj[aOrB]['index'];

    } else {  // Init.
        currentSynsetIndex = startSynsetIndex;
        document.querySelector('#target span.words').innerHTML = wordsStrFromArray(gameGraph[targetSynsetIndex][2]);
        document.querySelector('#target span.pos').innerHTML = gameGraph[targetSynsetIndex][3];
        document.querySelector('#target span.gloss').innerHTML = gameGraph[targetSynsetIndex][4];
    };
    const currSynsetSpan = document.querySelector('#curr-synset span');
    const newCurrentWords = gameGraph[currentSynsetIndex][2];
    currSynsetSpan.innerHTML = wordsStrFromArray(newCurrentWords);

    // TODO: !@#$!@#$!@#$ Just grabbing first of decoy/correct! Not jumbling correct/decoy!

    const newPointers = getPointers(currentSynsetIndex);
    for (const newAorB of ['a', 'b']) {
        nextSynsObj[newAorB]['index'] = newPointers[newAorB]['index'];
        nextSynsObj[newAorB]['pointer'].innerHTML = newPointers[newAorB]['pointer'];
        nextSynsObj[newAorB]['words'].innerHTML = `${newPointers[newAorB]['words']} `;
        nextSynsObj[newAorB]['pos'].innerHTML = newPointers[newAorB]['pos'];
        nextSynsObj[newAorB]['gloss'].innerHTML = newPointers[newAorB]['gloss'];
    };

    // Add arrow.
    const arrowArea = document.getElementById('arrow-area');
    const newArrow = document.createElement('img');
    newArrow.src = '/static/arrow_outline.png';
    arrowArea.appendChild(newArrow);

    if (aOrB === 'b') {
        // Add strike.
        currentStrikes += 1;
        const strikeBox = document.getElementById(`strike-box-${currentStrikes}`)
        const newX = document.createElement('img');
        newX.src = '/static/red_x.png';
        strikeBox.appendChild(newX);
    };
};


for (const aOrB of ['a', 'b']) {

    nextSynsObj[aOrB]['area'].addEventListener('click', () => choose(aOrB));


    // nextSynsObj[aOrB]['area'].addEventListener('click', () => {

        // currentSynsetIndex = nextSynsObj[aOrB]['index'];
        // const currSynsetSpan = document.querySelector('#curr-synset span');
        // const newCurrentWords = gameGraph[currentSynsetIndex][2];
        // currSynsetSpan.innerHTML = wordsStrFromArray(newCurrentWords);

        // // TODO: !@#$!@#$!@#$ Just grabbing first of decoy/correct! Not jumbling correct/decoy!

        // const newPointers = getPointers(currentSynsetIndex);
        // for (const newAorB of ['a', 'b']) {
        //     nextSynsObj[newAorB]['index'] = newPointers[newAorB]['index'];
        //     nextSynsObj[newAorB]['pointer'].innerHTML = newPointers[newAorB]['pointer'];
        //     nextSynsObj[newAorB]['words'].innerHTML = newPointers[newAorB]['words'];
        //     nextSynsObj[newAorB]['pos'].innerHTML = newPointers[newAorB]['pos'];
        //     nextSynsObj[newAorB]['gloss'].innerHTML = newPointers[newAorB]['gloss'];
        // };
    // });
};








const strikeArea = document.getElementById('strike-area');
for (let strikeCount = 0; strikeCount < totalStrikes; strikeCount++) {
    const newStrikeBox = document.createElement('div');
    newStrikeBox.id = (`strike-box-${strikeCount + 1}`);
    newStrikeBox.classList.add('strike-box');
    strikeArea.appendChild(newStrikeBox);
};




// function asdf() {

//     // <div id="strike-area">
//     //         <div class="strike-box">
//     //             <img src="/static/red_x.png">

//     // const fragment = document.createDocumentFragment();
//     // const li = fragment
//     // .appendChild(document.createElement('section'))
//     // .appendChild(document.createElement('ul'))
//     // .appendChild(document.createElement('li'));
//     // li.textContent = 'hello world';
//     // document.body.appendChild(fragment);

// };



// window.addEventListener('keydown', () => {
//     asdf();
// });









// const choiceAreaA = document.getElementById('next-syn-a-text');
// choiceAreaA.addEventListener('click', () => {

//     currentSynsetIndex = pointerIndex;
//     const currentSynsetData = gameGraph[currentSynsetIndex];
//     const currSynsetSpan = document.querySelector('#curr-synset span');
//     currSynsetSpan.innerHTML = wordsStrFromArray(currentSynsetData[2]);

//     // TODO: !@#$!@#$!@#$ Just grabbing first of decoy/correct! Not jumbling correct/decoy!

//     pointerIndex = null;
//     let correctPointerPhrase = 'pointer';
//     let correctWordsStr = 'words';
//     let correctPosStr = 'pos';
//     let correctGlossStr = 'gloss';
//     const allCorrectPointers = Object.keys(currentSynsetData[0]);
//     if (allCorrectPointers.length > 0) {
//         pointerIndex = allCorrectPointers[0];
//         const firstCorrectSynPointerSym = currentSynsetData[0][pointerIndex];
//         correctPointerPhrase = pointer_key[firstCorrectSynPointerSym];
//         correctWordsStr = wordsStrFromArray(gameGraph[pointerIndex][2]);
//         correctPosStr = gameGraph[pointerIndex][3];
//         correctGlossStr = gameGraph[pointerIndex][4];
//     };
//     pointerSpanA.innerHTML = correctPointerPhrase;
//     wordsSpanA.innerHTML = `${correctWordsStr} `;
//     posSpanA.innerHTML = correctPosStr;
//     glossSpanA.innerHTML = correctGlossStr;



//     nextSynsetIndexB = null;
//     let decoyPointerPhrase = 'pointer';
//     let decoyWordsStr = 'words';
//     let decoyPosStr = 'pos';
//     let decoyGlossStr = 'gloss';
//     const allDecoyPointers = Object.keys(currentSynsetData[1]);
//     if (allDecoyPointers.length > 0) {
//         nextSynsetIndexB = allDecoyPointers[0];
//         const firstDecoySynPointerSym = currentSynsetData[1][nextSynsetIndexB];
//         decoyPointerPhrase = pointer_key[firstDecoySynPointerSym];
//         decoyWordsStr = wordsStrFromArray(gameGraph[nextSynsetIndexB][2]);
//         decoyPosStr = gameGraph[nextSynsetIndexB][3];
//         decoyGlossStr = gameGraph[nextSynsetIndexB][4];
//     };
//     pointerSpanB.innerHTML = decoyPointerPhrase;
//     wordsSpanB.innerHTML = `${decoyWordsStr} `;
//     posSpanB.innerHTML = decoyPosStr;
//     glossSpanB.innerHTML = decoyGlossStr;

// });


// const choiceAreaB = document.getElementById('next-syn-b-text');
// choiceAreaB.addEventListener('click', () => {

//     const pointerSpanA = document.querySelector('#next-syn-a-text span.pointer');
//     const pointerSpanB = document.querySelector('#next-syn-b-text span.pointer');
//     const wordsSpanA = document.querySelector('#next-syn-a-text span.words');
//     const wordsSpanB = document.querySelector('#next-syn-b-text span.words');
//     const posSpanA = document.querySelector('#next-syn-a-text span.pos');
//     const posSpanB = document.querySelector('#next-syn-b-text span.pos');
//     const glossSpanA = document.querySelector('#next-syn-a-text span.gloss');
//     const glossSpanB = document.querySelector('#next-syn-b-text span.gloss');

//     currentSynsetIndex = nextSynsetIndexB;
//     const currentSynsetData = gameGraph[currentSynsetIndex];
//     const currSynsetSpan = document.querySelector('#curr-synset span');
//     currSynsetSpan.innerHTML = wordsStrFromArray(currentSynsetData[2]);

//     // TODO: !@#$!@#$!@#$ Just grabbing first of decoy/correct! Not jumbling correct/decoy!

//     pointerIndex = Object.keys(currentSynsetData[0])[0];
//     const firstCorrectSynPointerSym = currentSynsetData[0][pointerIndex];
//     pointerSpanA.innerHTML = pointer_key[firstCorrectSynPointerSym];
//     wordsStr = wordsStrFromArray(gameGraph[pointerIndex][2]);
//     wordsSpanA.innerHTML = `${wordsStr} `;
//     posSpanA.innerHTML = gameGraph[pointerIndex][3];
//     glossSpanA.innerHTML = gameGraph[pointerIndex][4];

//     nextSynsetIndexB = Object.keys(currentSynsetData[1])[0];
//     const firstDecoySynPointerSym = currentSynsetData[1][nextSynsetIndexB];
//     pointerSpanB.innerHTML = pointer_key[firstDecoySynPointerSym];
//     wordsStr = wordsStrFromArray(gameGraph[nextSynsetIndexB][2]);
//     wordsSpanB.innerHTML = `${wordsStr} `;
//     // wordsSpanA.innerHTML = wordsStrFromArray(gameGraph[nextSynsetIndexB][2]);
//     posSpanB.innerHTML = gameGraph[nextSynsetIndexB][3];
//     glossSpanB.innerHTML = gameGraph[nextSynsetIndexB][4];

// });





function wordsStrFromArray(wordsArray) {
    let synsetWordString = '';
    for (let wordNum = 0; wordNum < wordsArray.length; wordNum++) {
        if (wordNum > 0) synsetWordString += ', ';
        synsetWordString += wordsArray[wordNum];
    };
    return synsetWordString;
};

</script>

</html>
